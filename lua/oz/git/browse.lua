-- This is entirely generated by Gemini almost.
local M = {}

local run_command = require("oz.util.shell").run_command

-- Main function to browse the git repository file/directory
function M.browse(target_path)
	-- 1. Determine the target path (current file or provided argument)
	target_path = target_path or vim.fn.expand("%:p")
	if target_path == "" then
		vim.notify("No file path available (buffer is unnamed or argument missing).", vim.log.levels.WARN)
		return
	end
	target_path = vim.fn.fnamemodify(target_path, ":p") -- Ensure absolute path

	-- 2. Find the Git repository root
	local target_dir = vim.fn.isdirectory(target_path) == 1 and target_path or vim.fn.fnamemodify(target_path, ":h")
	local ok_root, git_root = run_command({ "git", "rev-parse", "--show-toplevel" }, target_dir)
	if not ok_root then
		vim.notify("Not inside a Git repository or git command failed: " .. git_root, vim.log.levels.ERROR)
		return
	end
	git_root = vim.fn.trim(git_root) -- Remove potential trailing newline/whitespace

	-- 3. Get the remote URL (try 'origin' first)
	local ok_remote, remote_url = run_command({ "git", "remote", "get-url", "origin" }, git_root)
	if not ok_remote then
		-- Maybe try other remotes? For now, just error out.
		-- local ok_remotes_list, remotes_list = run_command({'git', 'remote'}, git_root)
		-- if ok_remotes_list and remotes_list ~= '' then
		--    local first_remote = vim.fn.split(remotes_list, '\n')[1]
		--    ok_remote, remote_url = run_command({'git', 'remote', 'get-url', first_remote}, git_root)
		-- end
		-- if not ok_remote then
		vim.notify('Could not get remote URL for "origin". ' .. remote_url, vim.log.levels.ERROR)
		return
		-- end
	end
	remote_url = vim.fn.trim(remote_url)

	-- 4. Get the current branch name or commit hash
	local ok_branch, branch = run_command({ "git", "rev-parse", "--abbrev-ref", "HEAD" }, git_root)
	if not ok_branch or branch == "HEAD" then -- If detached HEAD or error
		local ok_hash, hash = run_command({ "git", "rev-parse", "HEAD" }, git_root)
		if not ok_hash then
			vim.notify("Could not get current branch or commit hash: " .. (hash or branch), vim.log.levels.ERROR)
			return
		end
		branch = vim.fn.trim(hash) -- Use commit hash
	else
		branch = vim.fn.trim(branch) -- Use branch name
	end

	-- 5. Calculate the relative path from git root
	-- Ensure consistent path separators, remove trailing slashes from root for gsub
	local clean_git_root = git_root:gsub("/$", ""):gsub("\\$", "")
	local relative_path = target_path:match("^" .. vim.pesc(clean_git_root) .. "(.*)$")
	-- local relative_path = target_path:gsub("^" .. vim.fn.escape(clean_git_root, "/\\"), "") -- Escape path chars for pattern
	relative_path = relative_path:gsub("^[/\\]", "") -- Remove leading slash/backslash
	relative_path = relative_path:gsub("\\", "/") -- Convert backslashes to forward slashes for URL

	-- 6. Convert remote URL to a browsable HTTPS URL base
	local base_url
	-- SSH format: git@hostname:user/repo.git
	if remote_url:match("^git@") then
		base_url = remote_url:gsub("^git@", "https://")
		base_url = base_url:gsub(":", "/")
		base_url = base_url:gsub("%.git$", "")
		-- SSH protocol format: ssh://git@hostname/user/repo.git
	elseif remote_url:match("^ssh://") then
		base_url = remote_url:gsub("^ssh://[^@]+@", "https://") -- Remove ssh://user@
		base_url = base_url:gsub("%.git$", "")
		-- HTTPS format: https://hostname/user/repo.git (or https://user@hostname/...)
	elseif remote_url:match("^https://") then
		base_url = remote_url:gsub("^https://[^@]+@", "https://") -- Remove potential user@
		base_url = base_url:gsub("%.git$", "")
	else
		vim.notify("Unsupported remote URL format: " .. remote_url, vim.log.levels.ERROR)
		return
	end

	-- 7. Determine the path segment based on hosting service (heuristic)
	local path_segment = "/blob/" -- GitHub, GitLab, Gitea, Codeberg default
	if base_url:match("bitbucket%.org") then
		path_segment = "/src/"
		-- Azure DevOps needs a different structure entirely, complex to handle generically
		-- Example: https://dev.azure.com/{org}/{project}/_git/{repo}?path=/{filepath}&version=GB{branch}
	elseif base_url:match("dev%.azure%.com") or base_url:match("visualstudio%.com") then
		vim.notify("Azure DevOps has a unique URL structure, attempting standard format may fail.", vim.log.levels.WARN)
		-- If targeting a directory, use '/tree/' instead of '/blob/' or '/src/'
		if vim.fn.isdirectory(target_path) == 1 then
			path_segment = "/tree/"
		end
		-- For Azure, might need special URL construction here if generic fails often
		-- local final_url = base_url .. "?path=" .. vim.uri.encode(relative_path) .. "&version=GB" .. branch
		-- Let's proceed with generic first, see below.
	end

	-- Check if the target is a directory to adjust the path segment if needed
	if vim.fn.isdirectory(target_path) == 1 then
		if path_segment == "/blob/" then
			path_segment = "/tree/"
		end
		if path_segment == "/src/" then
			path_segment = "/browse/"
		end -- Bitbucket uses /browse for dirs
		-- If relative_path is empty, we are Browse the repo root
		if relative_path == "" then
			path_segment = "/tree/" -- Most services use /tree/ for root
			branch = branch -- Use branch/commit as is
			relative_path = "" -- No relative path needed
		end
	end

	-- 8. Construct the final URL
	local final_url
	-- Handle Azure DevOps potentially differently if needed (see path_segment logic)
	if
		(base_url:match("dev%.azure%.com") or base_url:match("visualstudio%.com"))
		and vim.fn.isdirectory(target_path) ~= 1
		and relative_path ~= ""
	then
		-- Attempt Azure-specific file URL construction
		-- Note: URI encoding might be needed for branch/path, handled by open command usually
		final_url = base_url .. "?path=" .. "/" .. relative_path .. "&version=GB" .. branch .. "&line=1" -- Add line=1 maybe
		vim.notify("Using Azure-specific URL format.", vim.log.levels.INFO)
	else
		-- Standard construction for others or Azure directories/root
		final_url = table.concat({ base_url, path_segment, branch, "/", relative_path }, "")
		final_url = final_url:gsub("///", "/"):gsub("//", "/")
		final_url = final_url:gsub(":/", "://")
	end

	-- 9. Determine the OS-specific open command
	local open_cmd
	if vim.fn.has("macunix") == 1 then
		open_cmd = "open"
	elseif vim.fn.has("win32") == 1 then
		open_cmd = "start" -- Use 'start' for URLs/files on Windows
	else -- Assume Linux/other Unix-like
		open_cmd = "xdg-open"
	end

	local open_job_id = vim.fn.jobstart({ open_cmd, final_url }, { detach = true })

	if not open_job_id or open_job_id <= 0 then
		vim.notify("Failed to execute command: " .. open_cmd .. " " .. final_url, vim.log.levels.ERROR)
		-- Fallback attempt with os.execute (might block briefly, less safe quoting)
		-- os.execute(open_cmd .. " " .. vim.fn.shellescape(final_url))
	end
end

return M
