local M = {}

-- Get the current Neovim executable path
local function get_nvim_path()
    return vim.v.progpath
end

-- List of Git commands that use an editor
local editor_commands = {
    -- Command name and whether it requires --wait
    ["commit"] = true,       -- git commit (opens COMMIT_EDITMSG)
    ["merge"] = true,        -- git merge with conflicts
    ["rebase"] = true,       -- git rebase -i
    ["revert"] = true,       -- git revert with -e
    ["tag"] = true,          -- git tag with -e
    ["edit"] = true,         -- git config --edit
    ["cherry-pick"] = true,  -- git cherry-pick with conflicts
}

-- Commands that need special arg detection to determine if they'll use an editor
local special_commands = {
    ["rebase"] = function(args)
        -- Only use Neovim for interactive rebases (-i or --interactive)
        return args:match("%-i") or args:match("%-%-interactive")
    end,
    ["tag"] = function(args)
        -- Only use Neovim for tags with -a and -e
        return args:match("%-e") or args:match("%-a") or args:match("%-%-annotate")
    end,
    ["config"] = function(args)
        -- Only use Neovim for config with --edit
        return args:match("%-e") or args:match("%-%-edit")
    end,
}

-- Check if this command needs the editor
local function needs_editor(cmd, args)
    if editor_commands[cmd] then
        -- If it's a special command, check the args
        if special_commands[cmd] then
            return special_commands[cmd](args)
        end
        return true
    end
    return false
end

-- Create a temporary script that will invoke the editor
local function create_editor_script()
    -- Create a temporary directory for our script if it doesn't exist
    local tmp_dir = vim.fn.stdpath("cache") .. "/git_nvim_editor"
    vim.fn.mkdir(tmp_dir, "p")

    -- Create a unique filename for this session
    local script_path = tmp_dir .. "/nvim_git_editor.sh"

    -- Create an editor script that will use the current Neovim instance
    local nvim_path = get_nvim_path()
    local script_content = [[
    #!/bin/sh
    # This script is automatically generated by the git-nvim plugin
    # It acts as a bridge between Git and Neovim for editor operations

    # Use the current Neovim instance
    NVIM="]] .. nvim_path .. [["

    # Execute Neovim with the file Git wants to edit
    # The --headless=false is important to ensure UI is shown
    "$NVIM" --headless=false --noplugin -c "set bufhidden=delete" "$@"
    ]]

    -- Write the script to file
    local file = io.open(script_path, "w")
    if file then
        file:write(script_content)
        file:close()

        -- Make the script executable
        vim.fn.system("chmod +x " .. script_path)
        return script_path
    else
        vim.notify("Failed to create git editor script", vim.log.levels.ERROR)
        return nil
    end
end

-- Set up Neovim as the Git editor for this session
local function setup_git_editor()
    local editor_script = create_editor_script()
    if not editor_script then return false end

    -- Set environment variables to use our script as the editor
    vim.env.GIT_EDITOR = editor_script

    return true
end

-- Execute Git command with appropriate editor setup
function M.execute_git_command(cmd_args, callback)
    -- Parse the command to determine if we need to set up the editor
    local args = vim.split(cmd_args, " ")
    local git_cmd = args[1]
    local all_args = table.concat({unpack(args, 2)}, " ")

    -- Check if this command needs the editor
    if needs_editor(git_cmd, all_args) then
        if not setup_git_editor() then
            vim.notify("Failed to set up git editor integration", vim.log.levels.ERROR)
            return
        end
    end

    -- Your async execution logic would go here
    -- For example, with plenary.nvim's job:
    if callback then
        -- For async execution, you would call the callback when done
        -- This is a placeholder for your actual implementation
        vim.defer_fn(function()
            callback("Command executed: git " .. cmd_args)
        end, 100)
    else
        -- Synchronous fallback
        local result = vim.fn.system("git " .. cmd_args)
        return result
    end
end

-- Handle Git commands that open an editor
function M.handle_editor_command(command, args, callback)
    -- Combine command and args
    local full_command = command
    if args and args ~= "" then
        full_command = full_command .. " " .. args
    end

    -- Execute with editor setup
    return M.execute_git_command(full_command, callback)
end

-- Create a buffer for editing Git commits directly
function M.create_commit_buffer(args)
    -- Create a new buffer for the commit message
    local bufnr = vim.api.nvim_create_buf(true, false)
    vim.api.nvim_buf_set_name(bufnr, "COMMIT_EDITMSG")

    -- Set buffer options
    vim.api.nvim_buf_set_option(bufnr, "filetype", "gitcommit")
    vim.api.nvim_buf_set_option(bufnr, "bufhidden", "wipe")

    -- Pre-populate with the commit template
    local template = vim.fn.system("git config --get commit.template")
    if template and template ~= "" then
        vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, vim.split(template, "\n"))
    end

    -- Add the commented instructions
    local instructions = {
        "# Please enter the commit message for your changes. Lines starting",
        "# with '#' will be ignored, and an empty message aborts the commit.",
        "#",
        "# On branch " .. vim.fn.system("git branch --show-current"):gsub("\n", ""),
        "# Changes to be committed:",
        "#"
    }

    -- Get the status of files to be committed
    local status_lines = vim.split(vim.fn.system("git status --porcelain"), "\n")
    for _, line in ipairs(status_lines) do
        if line ~= "" then
            table.insert(instructions, "#   " .. line)
        end
    end

    -- Append instructions to the buffer
    vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, instructions)

    -- Switch to the buffer
    vim.api.nvim_set_current_buf(bufnr)

    -- Add command to finalize the commit
    vim.api.nvim_create_user_command("GitCommitFinalize", function()
        -- Get the commit message from the buffer
        local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
        local message = ""
        for _, line in ipairs(lines) do
            if not line:match("^%s*#") and line ~= "" then
                message = message .. line .. "\n"
            end
        end

        -- If message is empty, abort the commit
        if message:match("^%s*$") then
            vim.notify("Aborting commit due to empty commit message", vim.log.levels.WARN)
            vim.cmd("bdelete!")
            return
        end

        -- Write message to a temporary file
        local tmp_file = vim.fn.tempname()
        local file = io.open(tmp_file, "w")
        if file then
            file:write(message)
            file:close()

            -- Execute the commit with the message
            local commit_args = "commit -F " .. tmp_file
            if args and args ~= "" then
                commit_args = commit_args .. " " .. args
            end

            local result = vim.fn.system("git " .. commit_args)
            vim.notify(result, vim.log.levels.INFO)

            -- Clean up
            vim.fn.delete(tmp_file)
            vim.cmd("bdelete!")
        else
            vim.notify("Failed to write commit message", vim.log.levels.ERROR)
        end
    end, {})

    -- Key mappings for the commit buffer
    vim.api.nvim_buf_set_keymap(bufnr, "n", "<leader>cc", ":GitCommitFinalize<CR>", { noremap = true, silent = true })

    -- Notify user about the commit command
    vim.notify("Enter commit message and use <leader>cc to commit or :GitCommitFinalize", vim.log.levels.INFO)
end

-- Integration with the main Git command wrapper
function M.setup(git_command_module)
    -- Create commands that explicitly open an editor
    vim.api.nvim_create_user_command("GitCommit", function(opts)
        M.create_commit_buffer(opts.args)
    end, { nargs = "*" })

    vim.api.nvim_create_user_command("GitRebase", function(opts)
        local args = opts.args
        if not args:match("%-i") and not args:match("%-%-interactive") then
            args = "-i " .. args
        end
        M.handle_editor_command("rebase", args)
    end, { nargs = "*" })

    -- You could add similar commands for other editor-based Git operations

    -- Return functions that can be used by the main Git module
    return {
        needs_editor = needs_editor,
        execute_git_command = M.execute_git_command,
        handle_editor_command = M.handle_editor_command
    }
end

return M
